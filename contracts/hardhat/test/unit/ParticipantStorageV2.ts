import { loadFixture } from '@nomicfoundation/hardhat-toolbox/network-helpers';
import { expect } from 'chai';
import hre, { ethers } from 'hardhat';
import { registerToken } from './TokenRegistryV1';
import { mockRelayerEthersLastTransaction } from './utils/RelayerMockEthers';
import { basicDeploySetupUpgrade } from './utils/basicDeploySetupUpgrade';
import { extendConfig } from 'hardhat/config';

describe('ParticipantStorage V2', function () {
  it('Should broadcast updates to all participants whenever there is a new participant registered', async function () {
    const { participantStorage, endpointMappings, resourceRegistry, messageIdsAlreadyProcessedOnDeploy, participantStorageReplicaPL1, participantStorageReplicaPL2 } =
      await loadFixture(basicDeploySetupUpgrade);

    const messageIdsAlreadyProcessed = { ...messageIdsAlreadyProcessedOnDeploy }; // should copy because fixture does not update the values of a object reference

    await participantStorage.addParticipant({
      chainId: 1111111,
      role: 1,
      ownerId: hre.ethers.Wallet.createRandom().address,
      name: 'TestParticipant'
    });
    await participantStorage.updateStatus(1111111, 1);
    await mockRelayerEthersLastTransaction(endpointMappings, messageIdsAlreadyProcessed, resourceRegistry);

    // Check if received
    await expect(participantStorageReplicaPL1.validateMessageParticipants(1111111, 1111111)).to.not.be.rejected;
    // Check if received
    await expect(participantStorageReplicaPL2.validateMessageParticipants(1111111, 1111111)).to.not.be.rejected;
  });

  it('Should broadcast all the participants registered on CC to participant when requested', async function () {
    const { participantStorage, endpointMappings, chainIdPL1, resourceRegistry, messageIdsAlreadyProcessedOnDeploy, participantStorageReplicaPL1, endpointPL1 } =
      await loadFixture(basicDeploySetupUpgrade);

    const messageIdsAlreadyProcessed = { ...messageIdsAlreadyProcessedOnDeploy }; // should copy because fixture does not update the values of a object reference

    const mockMappings = { ...endpointMappings }; // creates a copy to be able to change withou impact other tests
    await participantStorage.updateStatus(chainIdPL1, 0);
    await mockRelayerEthersLastTransaction(mockMappings, messageIdsAlreadyProcessed, resourceRegistry);

    mockMappings[chainIdPL1] = null; // removing PL1 from mappings to not send cross-chain updates to the destination

    await participantStorage.addParticipant({
      chainId: 1111111,
      role: 1,
      ownerId: hre.ethers.Wallet.createRandom().address,
      name: 'TestParticipant'
    });
    await participantStorage.updateStatus(1111111, 1);
    await participantStorage.addParticipant({
      chainId: 2222222,
      role: 2,
      ownerId: hre.ethers.Wallet.createRandom().address,
      name: 'TestParticipant2'
    });
    await participantStorage.updateStatus(2222222, 1);

    await mockRelayerEthersLastTransaction(mockMappings, messageIdsAlreadyProcessed, resourceRegistry);

    // Check if the inserted participants doesn't included on PL1 before requested
    await expect(participantStorageReplicaPL1.validateMessageParticipants(1111111, 1111111)).to.be.rejectedWith('Participant not registered');

    // Request All Participants Updates
    await participantStorageReplicaPL1.requestAllParticipantsDataFromCommitChain();
    mockMappings[chainIdPL1] = endpointPL1 // include PL1 again in mock relayer
    await mockRelayerEthersLastTransaction(mockMappings, messageIdsAlreadyProcessed, resourceRegistry);

    // Check if received
    await expect(participantStorageReplicaPL1.validateMessageParticipants(1111111, 1111111)).to.not.be.rejected;
  });

  it('Should reject updates on replica that was not generated by the commitchain', async function () {
    const { raylsMessageExecutorPL1, participantStorageReplicaPL1, owner } = await loadFixture(basicDeploySetupUpgrade);

    await hre.network.provider.send('hardhat_setBalance', [
      await raylsMessageExecutorPL1.getAddress(),
      '0x16345785D8A0000' // Amount in wei (e.g., 10000 Ether)
    ]);
    // Impersonate the desired address
    await hre.network.provider.request({
      method: 'hardhat_impersonateAccount',
      params: [await raylsMessageExecutorPL1.getAddress()] // The address you want to impersonate
    });

    // Obtain a signer object for the impersonated account
    const signer = await ethers.getSigner(await raylsMessageExecutorPL1.getAddress());

    await expect(
      participantStorageReplicaPL1.connect(signer).addOrUpdateParticipants([
        {
          chainId: '0',
          role: '1',
          status: '1',
          ownerId: await owner.getAddress(),
          name: 'foo',
          createdAt: '0',
          updatedAt: '0'
        }
      ])
    ).to.be.rejectedWith('This method only receive calls from commit chain.');
  });

  it('Should reject arbitrary messages FROM a non-active member', async function () {
    const { participantStorage, tokenRegistry, tokenPL1, owner, chainIdPL1, chainIdPL2, endpointMappings, messageIdsAlreadyProcessedOnDeploy, resourceRegistry } =
      await loadFixture(basicDeploySetupUpgrade);

    const messageIdsAlreadyProcessed = { ...messageIdsAlreadyProcessedOnDeploy };
    const resourceId = (await registerToken(tokenPL1, tokenRegistry, endpointMappings, messageIdsAlreadyProcessed, resourceRegistry)).resourceId;
    await expect(tokenPL1.teleport(await owner.getAddress(), 10, chainIdPL2)).to.not.be.rejected;

    await participantStorage.updateStatus(chainIdPL1, 0);
    await mockRelayerEthersLastTransaction(endpointMappings, messageIdsAlreadyProcessed, resourceRegistry);

    await expect(tokenPL1.teleport(await owner.getAddress(), 10, chainIdPL2)).to.be.rejectedWith('Participant not in an active status');
  });

  it('Should reject arbitrary messages TO a non-active member', async function () {
    const { participantStorage, tokenRegistry, tokenPL1, owner, chainIdPL2, endpointMappings, messageIdsAlreadyProcessedOnDeploy, resourceRegistry } = await loadFixture(basicDeploySetupUpgrade);

    const messageIdsAlreadyProcessed = { ...messageIdsAlreadyProcessedOnDeploy };
    const resourceId = (await registerToken(tokenPL1, tokenRegistry, endpointMappings, messageIdsAlreadyProcessed, resourceRegistry)).resourceId;
    await expect(tokenPL1.teleport(await owner.getAddress(), 10, chainIdPL2)).to.not.be.rejected;

    await participantStorage.updateStatus(chainIdPL2, 0);
    await mockRelayerEthersLastTransaction(endpointMappings, messageIdsAlreadyProcessed, resourceRegistry);

    await expect(tokenPL1.teleport(await owner.getAddress(), 10, chainIdPL2)).to.be.revertedWith("Participant not in an active status");
  });

  it('Should Set Babyjubjub keys for a chainId', async function () {
    
    const { participantStorage, chainIdPL1, chainIdPL2, chainIdPL3, chainIdPL4, owner, otherAccount, account3, account4, account5, account6} = await loadFixture(basicDeploySetupUpgrade);


    const addr = await owner.getAddress();

    const babyjubjubinits = await participantStorage.getEnygmaBabyJubjubKeysByChainId(chainIdPL1);
    console.log("ðŸš€ ~ babyjubjubinits:", babyjubjubinits)
    
    
    const addressesPl1 = [addr];
    await participantStorage.setEnygmaBabyJubjubKeys(chainIdPL1, 123123123, 54654654654, addressesPl1)

    const babyJubjubKeys = await participantStorage.getEnygmaBabyJubjubKeysByChainId(chainIdPL1);    
    console.log("ðŸš€ ~ babyJubjubKeys:", babyJubjubKeys)
    
    expect(babyJubjubKeys[0]).to.be.equal(123123123);
    expect(babyJubjubKeys[1]).to.be.equal(54654654654);    

    await expect(participantStorage.setEnygmaBabyJubjubKeys(chainIdPL1, 123123123, 54654654654, addressesPl1)).to.be.rejectedWith('Enygma Data for this chainId is already set!');

    const babyJujubAllData = await participantStorage.getEnygmaAllBabyJubjubKeys();
    
    expect(babyJujubAllData[0][0]).to.be.equal(123123123);
    expect(babyJujubAllData[0][1]).to.be.equal(54654654654);
    //expect(babyJujubAllData[0][2]).to.be.equal(addr);
    expect(babyJujubAllData[0][3]).to.be.equal(chainIdPL1);

    const addressesPl2 = [otherAccount];
    const addressesPl3 = [account3];
    const addressesPL4 = [account4, account5];
    
    await participantStorage.setEnygmaBabyJubjubKeys(chainIdPL2, 2222, 22223, addressesPl2)
    await participantStorage.setEnygmaBabyJubjubKeys(chainIdPL3, 3333, 22224, addressesPl3)
    await participantStorage.setEnygmaBabyJubjubKeys(chainIdPL4, 4444, 22225, addressesPL4)
    
    const secrets = await participantStorage.getEnygmaSecrets();
    console.log("ðŸš€ ~ secrets:", secrets)

    const secrets2 = await participantStorage.connect(otherAccount).getEnygmaSecrets();
    console.log("ðŸš€ ~ secrets2:", secrets2)

    const secrets3 = await participantStorage.connect(account3).getEnygmaSecrets();
    console.log("ðŸš€ ~ secrets3:", secrets3)
    
    const secrets4 = await participantStorage.connect(account4).getEnygmaSecrets();
    console.log("ðŸš€ ~ secrets4:", secrets4)

    const secrets42 = await participantStorage.connect(account5).getEnygmaSecrets();
    console.log("ðŸš€ ~ secrets4-2:", secrets42)

    await expect(participantStorage.connect(account6).getEnygmaSecrets()).to.be.rejectedWith('This address does not belong to any participant');

    // const data = participantStorage.enygmaData(); 
    // console.log(data);
    
  });
  

});
